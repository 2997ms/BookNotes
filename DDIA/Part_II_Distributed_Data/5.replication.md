# 数据复制
挑战：复制持续更改的数据

三种复制办法：
* single-leader
* multi-leader
* leaderless

折中考虑的地方：
* 同步复制还是异步复制
* 如何处理失败的副本

复制滞后，最终一致性：
* 读自己的写
* 单调读

## 单主节点复制
如何确保所有的副本都是一致的？

工作原理：
1. 指定某一个节点为主节点。只有主节点可以处理写请求。主节点将数据写入本地存储
2. 主节点把数据更改发送给所有从节点。所有从节点应用数据更改
3. 客户端在主节点或者从节点上读
### 同步复制与异步复制
#### 同步
优点：
* 从节点和主节点总是保持一致。不会丢数据

缺点：
* 失败的从节点会阻塞后续所有写操作

半同步：一个从节点同步，其它从节点异步
#### 全异步模式
缺点：
* 确认了的写操作也有可能丢。无法保证数据的持久化。
* 复制滞后问题

优点：
* 不管发生什么，可以持续响应写请求，吞吐量高。

### 添加新的从节点
可以在不停机、服务不中断的情况下完成从节点的添加。步骤如下：
1. 对主节点产生一个一致性快照
2. 拷贝快照到从节点上并应用
3. 请求快照之后的所有变更日志
4. 应用变更日志 (catch up)

可以自动化

### 处理节点失效
目标：尽管个别节点失效，保持系统总体的连续运行，并尽可能减小节点中断的影响
#### 从节点失效：追赶
节点恢复后请求落下的数据变更
#### 主节点失效：切换
步骤如下：
1. 确认主节点失效：超时机制。没有万无一失的方法能够知道问题在哪里
2. 选举新的主节点。共识问题（第 9 章）
3. 重新配置系统使得主节点生效。客户端也要重新配置。原来的主节点需要降级为从节点。

变数：
1. 从节点数据不完整。主节点失效后又重新上线，如何处理冲突的写请求？常见的方案是丢弃主节点上未完成复制的数据。
2. 如果数据库之外的其它系统以来于数据库的内容并一起协同使用，则数据丢弃的方案特别危险。会造成意料之外的 bug
3. 两个主节点。脑裂，非常危险，会发生冲突。
4. 如何设置合适的超时来检测主节点失效？太长了导致恢复慢，太短了导致不必要的切换。

分布式系统的核心基本问题：
* 节点失效
* 网络不可靠
* 副本一致性、持久性、可用性、延迟之间的权衡

### 复制日志的实现
#### 基于语句的复制
把操作语句直接发给从节点。

pros: 简单

cons:
* 非确定的函数在不同机器上会产生不同的结果
* 依赖于现有数据的操作，要求所有副本按照相同的顺序来执行语句。限制了系统的并发事务。
* 有副作用的语句在多个副本上可能会产生不同的副作用

#### 预写日志传输
每个写操作都会以追加的形式写到日志里面。直接把日志的追加转发给从节点。

cons:
* WAL 的日志描述过于底层，使得复制方案与存储引擎紧密耦合。使得无法支持从节点运行版本比主节点新。导致升级时必须停机。

#### 基于行的逻辑日志的复制
复制和存储引擎采用不同的日志格式，被称为逻辑日志。关系数据库的逻辑日志通常是指一系列记录来描述数据表行级别的写请求。

pros:
* 与存储引擎解耦，更容易向后兼容，从而可以不停机升级。甚至运行不同的存储引擎，从节点可以自己决定如何应用变更日志。
* 对于外部应用程序来说，逻辑日志更容易解析。(change data capture)

#### 基于触发器的复制
在某些情况下，我们需要更高的灵活性。例如：只复制一部分数据，从一种数据库复制到另一种数据库，定制冲突解决逻辑。

pros: 灵活性

cons:
* 开销更高
* 更容易出错
* 有更多限制

## 复制滞后问题
复制还带来了可扩展性和低延迟。对于读操作密集的负载，很适合使用主从复制。添加更多从副本，就可以提高读请求的吞吐量。但是，这种方法实际上只能使用异步复制。

不幸的是，在异步的情况下，会出现从节点落后于主节点的情况，应用会读到过期的信息。在停止写入后，从节点最终会赶上主节点并保持一致，称为最终一致性。

本节介绍三种复制滞后可能出现的问题，并给出相应的解决思路。

### 读自己的写
问题：往主节点写，从从节点读，可能会无法读取到刚刚写入的数据。看起来像是数据丢失了。

**写后读一致性**：也称为读写一致性。保证用户可以看到自己的写入。

解决方案：保证用户从包含更新的节点读取
* 可能会被修改的从主节点读取，否则在从节点读取
* 通过其它方案判断是否从主节点读取。例如跟踪从节点的复制滞后程度
* 客户端请求时带上最近一次写请求的时间戳，由包含该时间戳的节点提供服务。此时时间戳的同步是一个关键问题。

### 单调读 (Monotonic Reads)
问题：读取两次，出现了数据回滚的现象。原因是先从一个少量滞后的从节点读取，再从一个大量滞后的从节点读取。

单调读一致性：保证不会出现数据回滚的现象。比强一致性弱，但是比最终一致性强。

解决方案：每个用户总是从固定的同一个副本读取。例如，基于用户 ID 哈希选取副本。

### 前缀一致读 (Consistent Prefix Reads)
前缀一致读保证：对于一系列按照某个顺序发生的写请求，读取时总会按照写入的顺序读取到。
在分区数据库会出现的一个特殊问题。如果只有一个分区，则总是以相同顺序写入，不会发生这种问题。在分区的情况下，不同的分区独立运行，不存在全局写入顺序，导致不同的分区顺序不一样。

解决方案：
1. 确保任何具有因果关系的写入都由同一个分区处理。但是在某些应用中无法高效完成。
2. 有一些新的算法，显式追踪事件因果关系。

### 复制滞后的解决方案
使用最终一致性系统时，最好事先就思考这样的问题：如果复制延迟增加到几分钟甚至几小时，应用层的行为是什么样子？如果不可接受，就要提供比最终一致性更强的保证，例如写后读一致性。

某些情况下在应用层可以提供比底层数据库更强有力的保证。代价则是，应用层代码会变得复杂且容易出错。这也是事务存在的原因，事务是数据库提供更强保证的一种方式。

在分布式数据库中，很多系统放弃了支持事务，并断言在分布式系统中，最终一致性是无可避免的选择。这种观点虽然有一定道理，但是情况并不是这么简单。后面的章节会形成一个更为深入的观点。我们会理解事务，并寻找其它替代机制。

